#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  ,               sensorDigitalOut)
#pragma config(Sensor, dgtl2,  ,               sensorDigitalOut)
#pragma config(Sensor, dgtl3,  pneumatics2,    sensorDigitalOut)
#pragma config(Sensor, dgtl4,  pneumatics,     sensorDigitalOut)
#pragma config(Sensor, dgtl5,  liftEncoderR,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  liftEncoderL,   sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rbDrive,       tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           ltArm,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           rtArm,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           lmArm,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rmArm,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           lbArm,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           rbArm,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lfDrive,       tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           rfDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          lbDrive,       tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"

//Pneumatics Variables
bool cubeIntakeOut = false;
bool skyriseIntakeOut = true;

//Encoder Convertion Values
float lDriveMod = 0.0400;
float fDriveMod = 0.0400;
float rDriveMod = 0.0400;
float bDriveMod = 0.0400;
float lTurnMod = 0.0111;
float rTurnMod = 0.0111;
float liftMod = 0.0175;

//PID Variables
unsigned long lastTime = 0;
float outputPID = 0;
float lastEncoderValue = 0;
float errorSum = 0;
float maxSum = 0;
float minSum = 0;
float pMod = 0;
float iMod = 0;
float dMod = 0;
float sampleRate = 200;

//Calculated Encoder Variables
float driveEncoderInches = 0;
float liftHeightInches = 0;

//Default Constants
float skyriseHeightInches = 18;


void pre_auton()
{
	bStopTasksBetweenModes = true;
	nMotorEncoder[lfDrive] = nMotorEncoder[rfDrive] = 0;
}

void calcPID(float encoderValue, float targetValue)
{
	//Calculates time for sampleRate
   unsigned long now = time1[T1];
   float timeChange = (float)(now - lastTime);

   if (timeChange >= sampleRate)
   {
	   //Compute P,I, and D errors
	   float error = targetValue - encoderValue;
	   errorSum += (iMod * error);
	   float derivValue = encoderValue - lastEncoderValue;

	   //Clamps I error
	   if (errorSum > maxSum)
	     errorSum = maxSum;
	   else if (errorSum < minSum)
	     errorSum = minSum;

	   //Compute total error
	   outputPID = pMod * error + errorSum + dMod * derivValue;

	   //Set variables for next PID calculation
	   lastEncoderValue = encoderValue;
	   lastTime = now;
		}
		//Clamps PID output
		if (outputPID > 127)
			outputPID = 127;
		else if (outputPID < 127)
			outputPID = -127;
}

void setPIDMultiplier(float kP, float kI, float kD)
{
	pMod = kP;
	iMod = kI * sampleRate / 1000;
	dMod = kD / sampleRate / 1000;
}

void setPIDTiming(int sampleTime)
{
	if (sampleTime > 0)
	{
		iMod *= (sampleTime / sampleRate);
		dMod /= (sampleTime / sampleRate);
		sampleRate = (unsigned long)sampleTime;
	}
}

void setIErrorLimits(float lowerLimit, float upperLimit)
{

}

void drivePIDLoop(int direction)
{
	if (abs(nMotorEncoder[lfDrive]) > abs(nMotorEncoder[rfDrive]))
	{
		float targetValue = abs(nMotorEncoder[lfDrive]) - abs(nMotorEncoder[rfDrive]);
		calcPID(0,targetValue);
		if (direction == 1 || direction == 4) // if strafing left or backward
			motor[lfDrive] = motor[rbDrive] = 127 - outputPID;
		else if (direction == 2  || direction == 3) // if driving forward or right
			motor[lfDrive] = motor[rbDrive] = -127 + outputPID;
		else if (direction == 5) // if turning left
		{
			motor[lfDrive] = 127 - outputPID;
			motor[rbDrive] = -127 + outputPID;
		}
		else if (direction == 6) // if turning right
		{
			motor[lfDrive] = -127 + outputPID;
			motor[rbDrive] = 127 - outputPID;
		}
	}
	else if (abs(nMotorEncoder[lfDrive]) < abs(nMotorEncoder[rfDrive]))
	{
		float targetValue = abs(nMotorEncoder[rfDrive]) - abs(nMotorEncoder[lfDrive]);
		calcPID(0,targetValue);
		if (direction == 1 || direction == 4) // if strafing left or backward
			motor[rfDrive] = motor[lbDrive] = 127 - outputPID;
		else if (direction == 2  || direction == 3) // if driving forward or right
			motor[rfDrive] = motor[lbDrive] = -127 + outputPID;
		else if (direction == 5) // if turning left
		{
			motor[rfDrive] = 127 - outputPID;
			motor[lbDrive] = -127 + outputPID;
		}
		else if (direction == 6) // if turning right
		{
			motor[rfDrive] = -127 + outputPID;
			motor[lbDrive] = 127 - outputPID;
		}
	}


}

void drive(float forback, float turnlr, float strafelr) //normally Ch3,Ch1,Ch4
{
	motor[lbDrive] = forback+turnlr-strafelr;
	motor[lfDrive] = forback+turnlr+strafelr;
	motor[rbDrive] = forback-turnlr+strafelr;
	motor[rfDrive] = forback-turnlr-strafelr;
}

void buttonDrive(bool enable, bool forward, bool backward, bool left, bool right, bool turnLeft, bool turnRight) // hold a button to use buttons to drive
{
	while (enable)
	{
		int direction = 0;
		if (forward)
		{
			drive(127,0,0);
			direction = 2;
		}
		else if (backward)
		{
			drive(-127,0,0);
			direction = 4;
		}
		else if (left)
		{
			drive(0,0,127);
			direction = 1;
		}
		else if (right)
		{
			drive(0,0,-127);
			direction = 3;
		}
		else if (turnLeft)
		{
			drive(0,127,0);
			direction = 5;
		}
		else if (turnRight)
		{
			drive(0,-127,0);
			direction = 6;
		}
		drivePIDLoop(direction);
	}
	drive(0,0,0);
}

void arm(bool up, bool down, int speed) //normally 6U,6D,115
{
	if(up && !down) motor[lbArm] = motor[ltArm] = motor[lmArm] = motor[rbArm] = motor[rtArm] = motor[rmArm] = speed;
	else if(!up && down) motor[lbArm] = motor[ltArm] = motor[lmArm] = motor[rbArm] = motor[rtArm] = motor[rmArm] = -speed;
	else motor[lbArm] = motor[ltArm] = motor[lmArm] = motor[rbArm] = motor[rtArm] = motor[rmArm] = 15;
}

void cubeIntakeDeploy(bool button, bool button2) //normally 8D
{
	if(button && !cubeIntakeOut){
		SensorValue[pneumatics] = 1;
		cubeIntakeOut = true;
	}

   else if(button2 && cubeIntakeOut){
		SensorValue[pneumatics] = 0;
		cubeIntakeOut = false;
	}
}

void skyriseIntakeDeploy(bool button, bool button2) //normally 8R
{
	if(button && !skyriseIntakeOut){
		SensorValue[pneumatics2] = 1;
		skyriseIntakeOut = true;
	}

   else if(button2 && skyriseIntakeOut){
		SensorValue[pneumatics2] = 0;
		skyriseIntakeOut = false;
	}
}

void calcLiftHeight()
{
	liftHeightInches = (SensorValue[liftEncoderL] + SensorValue[liftEncoderR]) / 2 / liftMod;
}

void calcDriveEncoder(int direction) // provides encoder value for direction assigned
{
	if (direction == 1) // if strafing left
		driveEncoderInches = (nMotorEncoder[lfDrive] / sqrt(2)) + (nMotorEncoder[rfDrive] / sqrt(2)) / 2 / lDriveMod;
	else if (direction == 2) // if driving forward
		driveEncoderInches = (-nMotorEncoder[lfDrive] / sqrt(2)) + (nMotorEncoder[rfDrive]/ sqrt(2)) / 2 / fDriveMod;
	else if (direction == 3) // if strafing right
		driveEncoderInches = (-nMotorEncoder[lfDrive] / sqrt(2)) + (-nMotorEncoder[rfDrive] / sqrt(2)) / 2 / rDriveMod;
	else if (direction == 4) // if driving backward
		driveEncoderInches = (nMotorEncoder[lfDrive] / sqrt(2)) + (-nMotorEncoder[rfDrive] / sqrt(2)) / 2 / bDriveMod;
	else if (direction == 5) // if turning left
		driveEncoderInches = (nMotorEncoder[lfDrive] + nMotorEncoder[rfDrive]) / lTurnMod;
	else if (direction == 6) // if turning right
		driveEncoderInches = (-nMotorEncoder[lfDrive] + -nMotorEncoder[rfDrive]) / rTurnMod;
	else // for debugging
		writeDebugStreamLine("calcDriveEncoder runs");
}

void debugEncoders(bool isRaw) // prints raw encoder values/coverted values
{
	unsigned long now = time1[T2];
	float timeChange = (now - lastTime);

	if (timeChange >= sampleRate)
	{
		if (isRaw) //raw value setting
		{
			writeDebugStream("lDrive raw: %f / ", nMotorEncoder(lfDrive));
			writeDebugStream("rDrive raw: %f / ", nMotorEncoder(rfDrive));
			writeDebugStream("lLift raw: %f / ", SensorValue(liftEncoderL));
			writeDebugStream("rLift raw: %f / ", SensorValue(liftEncoderR));
		}

		else if (!isRaw) //converted value setting
		{
			writeDebugStream("lDrive inch: %f / ", calcDriveEncoder(1));
			writeDebugStream("fDrive inch: %f / ", calcDriveEncoder(2));
			writeDebugStream("rDrive inch: %f / ", calcDriveEncoder(3));
			writeDebugStream("bDrive inch: %f / ", calcDriveEncoder(4));
			writeDebugStream("lTurn inch: %f / ", calcDriveEncoder(5));
			writeDebugStream("rTurn inch: %f / ", calcDriveEncoder(6));
			writeDebugStream("Lift value: %f / ", calcLiftHeight());
		}
		lastTime = now;
		writeDebugStreamLine("");
	}
}

void debugPID(float encoderValue, float sampleValue, int debugType)
{
	if (debugType == 0) // drive PID
	{
		while (encoderValue < sampleValue)
		{
			break;
		}
	}

	else if (debugType == 1) // lift PID
	{
		while (encoderValue < sampleValue)
		{
			break;
		}
	}
}

void resetPID(bool setToDefault) //resets lastTime, errorSum, lastEncoderValue, outputPID, and driveEncoderInches
{
		if (setToDefault) // additonally resets PID modifiers, sampleRate, and liftHeightInches
		{
				pMod = 0;
				iMod = 0;
				dMod = 0;
				sampleRate = 0;
				liftHeightInches = 0;
		}
		else
		{
			lastTime = 0;
			errorSum = 0;
			lastEncoderValue = 0;
			outputPID = 0;
			driveEncoderInches = 0;
		}
}

void autoDrive(float speed, int direction) //for autonomous, not recommended for driver control
{
	if (direction == 1) // if strafing left
	   drive(0,0,speed);
	else if (direction == 2) // if driving forward
		drive(speed,0,0);
	else if (direction == 3) // if strafing right
		drive(0,0,-speed);
	else if (direction == 4) // if driving backward
		drive(-speed,0,0);
	else if (direction == 5) // if turning left
		drive(0,speed,0);
	else if (direction == 6) // if turning right
		drive(0,-speed,0);
}

void liftTo(float height)
{
	if (liftHeightInches < height)
	{
		while (liftHeightInches < height)
		{
			calcPID(liftHeightInches, height);
		}
	}
	else if (liftHeightInches > height)
	{
		while (liftHeightInches > height)
		{
			liftHeightInches = height - (liftHeightInches - height);
			calcPID(liftHeightInches, height);
		}
	}
}

void driveTo(float distance, float direction)
{
	while (driveEncoderInches < distance)
	{
		calcPID(driveEncoderInches, distance);
		autoDrive(outputPID, direction);
	}
}

void robotDeactivation()
{
	drive(0,0,0);
	arm(true,false,0);
	writeDebugStreamLine("Robot Deactivated.");
	wait1Msec(1000);
}

void liftSkyriseHeight(bool button)
{
	if (button)
		liftTo(skyriseHeightInches);
}

void liftToBottom(bool button)
{

}


void timedDriveAuton(int speed, int time) //drives away from tile, dropping preload cube in the process
{
	drive(speed, 0, 0);
	arm(true,false,115);
	wait1Msec(time/5);
	arm(false,false,0);
	wait1Msec(4*time/5);
	drive(0,0,0);
	cubeIntakeDeploy(true, false);
}

void timedSkyriseAuton() //*should* score a skyrise
{
	arm(true,false,115);
	wait1Msec(500);
	arm(false,false,0);
	drive(0,0,127);
	wait1Msec(500);
	drive(0,0,0);
	arm(false,true,100);
	wait1Msec(700);
	skyriseIntakeDeploy(true, false);
	arm(true,false,100);
	wait1Msec(500);
	arm(false,false,0);
	drive(0,127,0);
	wait1Msec(500);
	drive(0,0,0);
	arm(false,true,100);
	wait1Msec(1000);
	arm(false,false,0);
	skyriseIntakeDeploy(true, false);
	arm(true,false,110);
	wait1Msec(5000);
	arm(false,false,0);
}

void pidSkyriseAuton()
{

}

task autonomous()
{
	timedDriveAuton(127,5000);
	/*
	1. Raise elevator slightly.
	2. Strafe to skyrise holder.
	3. Move forward slightly.
	4. Lower elevator slightly.
	5. Activate Skyrise pneumatics.
	6. Raise elevator.
	7. Move backwards slightly away from Skyrise dock.
	8. Rotate 180 degrees around.
	9. Move forward slightly to Skyrise placeholder.
	10. Lower Skyrise into placeholder until Skyrise is lock in place.
	11. Move backward slightly, away from Skyrise.
	12. Rotate 180 degrees
	13. Repeat steps 3 to 13 until autonomous time runs out or no more Skyrise available.
	*/

	/*
	1. Move forward slightly.
	2. Strafe away from skyrise placeholders.
	3. Rotate 120 degrees to Skyrise placeholder.
	*/

}

task usercontrol() //user control, duh
{
	while (true)
	{
		activeControl:
		while (!vexRT[Btn5U] || !vexRT[Btn6D] || !vexRT[Btn6U] || !vexRT[Btn7L] || !vexRT[Btn8R])
		{
			drive(vexRT[Ch3], vexRT[Ch1], vexRT[Ch4]);
			arm(vexRT[Btn6U], vexRT[Btn6D], 120);
			if (!vexRT[Btn5D])
			{
				cubeIntakeDeploy(vexRT[Btn8D], vexRT[Btn8L]);
			  skyriseIntakeDeploy(vexRT[Btn7D], vexRT[Btn7R]);
			}
			else if (vexRT[Btn5D])
				buttonDrive(vexRT[Btn5D], vexRT[Btn7U], vexRT[Btn7D], vexRT[Btn7L], vexRT[Btn7R], vexRT[Btn8L], vexRT[Btn8D]);
			liftSkyriseHeight(vexRT[Btn5U]);
			debugEncoders(true);
		}
		robotDeactivation();
		if (vexRT[Btn5D] && vexRT[Btn5U] && vexRT[Btn6D] && vexRT[Btn6U] && vexRT[Btn7L] && vexRT[Btn8R])
			goto activeControl;
	}
}
